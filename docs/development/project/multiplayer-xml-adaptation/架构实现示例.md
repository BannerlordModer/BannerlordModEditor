# 架构实现示例

## 1. 统一序列化控制框架实现

### 1.1 核心接口和基类

```csharp
// 简化实现：统一序列化控制框架
// 原本实现：每个模型都要手动实现ShouldSerialize方法
// 简化实现：通过基类和特性提供统一的序列化控制

using System;
using System.Collections.Generic;
using System.Xml.Serialization;
using System.Reflection;

namespace BannerlordModEditor.Common.Serialization
{
    // 序列化控制特性
    [AttributeUsage(AttributeTargets.Property)]
    public class XmlSerializationControlAttribute : Attribute
    {
        public string ConditionMethod { get; set; } = "";
        public bool SerializeWhenNull { get; set; } = false;
        public bool SerializeWhenEmpty { get; set; } = false;
        public string DependentProperty { get; set; } = "";
    }

    // 统一序列化基类
    public abstract class XmlSerializableBase
    {
        private readonly Dictionary<string, Func<bool>> _serializationConditions = new();

        protected XmlSerializableBase()
        {
            InitializeSerializationConditions();
        }

        // 初始化序列化条件
        private void InitializeSerializationConditions()
        {
            var properties = GetType().GetProperties();
            foreach (var property in properties)
            {
                var controlAttribute = property.GetCustomAttribute<XmlSerializationControlAttribute>();
                if (controlAttribute != null)
                {
                    if (!string.IsNullOrEmpty(controlAttribute.ConditionMethod))
                    {
                        var method = GetType().GetMethod(controlAttribute.ConditionMethod);
                        if (method != null)
                        {
                            _serializationConditions[property.Name] = () => (bool)method.Invoke(this, null)!;
                        }
                    }
                    else
                    {
                        _serializationConditions[property.Name] = () => ShouldSerializeProperty(property.Name);
                    }
                }
            }
        }

        // 默认序列化条件
        protected virtual bool ShouldSerializeProperty(string propertyName)
        {
            var property = GetType().GetProperty(propertyName);
            if (property == null) return false;

            var value = property.GetValue(this);
            
            // 字符串检查
            if (value is string str)
            {
                return !string.IsNullOrEmpty(str);
            }
            
            // 集合检查
            if (value is System.Collections.ICollection collection)
            {
                return collection.Count > 0;
            }
            
            // 默认检查
            return value != null;
        }

        // 动态ShouldSerialize方法
        public bool ShouldSerialize(string propertyName)
        {
            return _serializationConditions.TryGetValue(propertyName, out var condition) && condition();
        }

        // 标记属性为需要序列化
        protected void MarkForSerialization(string propertyName, bool shouldSerialize = true)
        {
            if (_serializationConditions.ContainsKey(propertyName))
            {
                _serializationConditions[propertyName] = () => shouldSerialize;
            }
            else
            {
                _serializationConditions[propertyName] = () => shouldSerialize;
            }
        }

        // 清除所有序列化标记
        protected void ClearSerializationMarks()
        {
            _serializationConditions.Clear();
            InitializeSerializationConditions();
        }
    }
}
```

### 1.2 格式保持服务实现

```csharp
// 简化实现：XML格式保持服务
// 原本实现：在XmlTestUtils中硬编码各种特殊情况
// 简化实现：通过统一的服务接口处理格式保持

using System;
using System.Collections.Generic;
using System.Xml;
using System.Xml.Linq;
using System.Text.RegularExpressions;

namespace BannerlordModEditor.Common.Serialization
{
    // XML格式保持服务
    public class XmlFormatPreservationService : IXmlFormatPreservationService
    {
        private readonly Dictionary<string, EmptyElementStrategy> _emptyElementStrategies = new();

        public XmlFormatPreservationService()
        {
            // 初始化默认的空元素策略
            InitializeDefaultStrategies();
        }

        private void InitializeDefaultStrategies()
        {
            // 常见空元素的处理策略
            _emptyElementStrategies["definitions"] = EmptyElementStrategy.Preserve;
            _emptyElementStrategies["combat_parameters"] = EmptyElementStrategy.Preserve;
            _emptyElementStrategies["item_holsters"] = EmptyElementStrategy.Preserve;
            _emptyElementStrategies["voice_type_declarations"] = EmptyElementStrategy.Preserve;
        }

        public XmlFormatMetadata AnalyzeFormat(string xml)
        {
            var metadata = new XmlFormatMetadata();
            
            try
            {
                var doc = XDocument.Parse(xml);
                
                // 分析文档级别的格式
                AnalyzeDocumentFormat(doc, metadata);
                
                // 分析元素级别的格式
                AnalyzeElementFormats(doc.Root, metadata, "");
                
                return metadata;
            }
            catch (Exception)
            {
                return metadata; // 返回默认元数据
            }
        }

        private void AnalyzeDocumentFormat(XDocument doc, XmlFormatMetadata metadata)
        {
            // 分析XML声明
            metadata.HasDeclaration = doc.Declaration != null;
            
            // 分析缩进和换行符
            var xmlString = doc.ToString();
            if (xmlString.Contains("\r\n"))
            {
                metadata.LineEnding = "\r\n";
            }
            else if (xmlString.Contains("\n"))
            {
                metadata.LineEnding = "\n";
            }
            
            // 分析缩进
            var indentMatch = Regex.Match(xmlString, @"^(\s+)<", RegexOptions.Multiline);
            if (indentMatch.Success)
            {
                metadata.Indentation = indentMatch.Groups[1].Value;
            }
        }

        private void AnalyzeElementFormats(XElement? element, XmlFormatMetadata metadata, string parentPath)
        {
            if (element == null) return;

            var elementPath = string.IsNullOrEmpty(parentPath) ? element.Name.LocalName : $"{parentPath}.{element.Name.LocalName}";
            
            // 分析当前元素的格式
            var elementFormat = new XmlElementFormat
            {
                IsEmpty = !element.HasElements && !element.HasAttributes && string.IsNullOrEmpty(element.Value),
                IsSelfClosing = element.ToString().EndsWith("/>")
            };

            // 分析属性格式
            foreach (var attr in element.Attributes())
            {
                elementFormat.Attributes.Add(new XmlAttributeFormat
                {
                    Name = attr.Name.LocalName,
                    Value = attr.Value,
                    HasQuotes = true
                });
            }

            metadata.ElementFormats[elementPath] = elementFormat;

            // 递归分析子元素
            foreach (var child in element.Elements())
            {
                AnalyzeElementFormats(child, metadata, elementPath);
            }
        }

        public string PreserveFormat(string originalXml, string serializedXml)
        {
            var originalMetadata = AnalyzeFormat(originalXml);
            var serializedDoc = XDocument.Parse(serializedXml);
            
            // 应用格式保持
            ApplyFormatPreservation(serializedDoc.Root, originalMetadata, "");
            
            return serializedDoc.ToString();
        }

        private void ApplyFormatPreservation(XElement? element, XmlFormatMetadata metadata, string parentPath)
        {
            if (element == null) return;

            var elementPath = string.IsNullOrEmpty(parentPath) ? element.Name.LocalName : $"{parentPath}.{element.Name.LocalName}";
            
            if (metadata.ElementFormats.TryGetValue(elementPath, out var originalFormat))
            {
                // 处理空元素
                if (originalFormat.IsEmpty)
                {
                    var strategy = GetStrategy(element.Name.LocalName);
                    switch (strategy)
                    {
                        case EmptyElementStrategy.SelfClosing:
                            // 替换为自闭合标签
                            var selfClosing = $"<{element.Name.LocalName}{GetAttributesString(element)} />";
                            element.ReplaceWith(selfClosing);
                            break;
                        case EmptyElementStrategy.EmptyElement:
                            // 替换为空元素标签
                            var emptyElement = $"<{element.Name.LocalName}{GetAttributesString(element)}></{element.Name.LocalName}>";
                            element.ReplaceWith(emptyElement);
                            break;
                        case EmptyElementStrategy.Omit:
                            // 省略空元素
                            element.Remove();
                            break;
                        case EmptyElementStrategy.Preserve:
                        default:
                            // 保持原样
                            break;
                    }
                }
            }

            // 递归处理子元素
            foreach (var child in element.Elements().ToList())
            {
                ApplyFormatPreservation(child, metadata, elementPath);
            }
        }

        private string GetAttributesString(XElement element)
        {
            if (!element.HasAttributes) return "";
            
            var attributes = new List<string>();
            foreach (var attr in element.Attributes())
            {
                attributes.Add($"{attr.Name.LocalName}=\"{attr.Value}\"");
            }
            
            return attributes.Count > 0 ? " " + string.Join(" ", attributes) : "";
        }

        public bool ShouldPreserveEmptyElement(string elementName)
        {
            return _emptyElementStrategies.ContainsKey(elementName);
        }

        public EmptyElementStrategy GetStrategy(string elementName)
        {
            return _emptyElementStrategies.TryGetValue(elementName, out var strategy) 
                ? strategy 
                : EmptyElementStrategy.Preserve;
        }

        public void SetStrategy(string elementName, EmptyElementStrategy strategy)
        {
            _emptyElementStrategies[elementName] = strategy;
        }
    }
}
```

## 2. 业务逻辑保持架构实现

### 2.1 业务状态管理

```csharp
// 简化实现：业务状态管理
// 原本实现：业务逻辑分散在各个DO类中
// 简化实现：通过统一的接口和状态管理器集中管理

using System;
using System.Collections.Generic;

namespace BannerlordModEditor.Common.BusinessLogic
{
    // 业务状态接口
    public interface IBusinessState
    {
        string StateId { get; }
        object GetState();
        void SetState(object state);
        bool ValidateState();
        event EventHandler<StateChangedEventArgs> StateChanged;
        
        // 简化实现：业务状态快照
        object CreateSnapshot();
        void RestoreSnapshot(object snapshot);
    }

    // 状态变更事件参数
    public class StateChangedEventArgs : EventArgs
    {
        public string PropertyName { get; set; } = "";
        public object? OldValue { get; set; }
        public object? NewValue { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.Now;
        public string ChangeReason { get; set; } = "";
    }

    // 业务状态管理器
    public class BusinessStateManager : IBusinessStateManager
    {
        private readonly Dictionary<string, IBusinessState> _states = new();
        private readonly object _lock = new();

        public void RegisterState(IBusinessState state)
        {
            lock (_lock)
            {
                _states[state.StateId] = state;
                state.StateChanged += OnStateChanged;
            }
        }

        public void UnregisterState(string stateId)
        {
            lock (_lock)
            {
                if (_states.TryGetValue(stateId, out var state))
                {
                    state.StateChanged -= OnStateChanged;
                    _states.Remove(stateId);
                }
            }
        }

        public IBusinessState? GetState(string stateId)
        {
            lock (_lock)
            {
                return _states.TryGetValue(stateId, out var state) ? state : null;
            }
        }

        public void SyncStates()
        {
            lock (_lock)
            {
                // 简化实现：同步所有状态
                foreach (var state in _states.Values)
                {
                    if (!state.ValidateState())
                    {
                        // 触发状态验证失败事件
                        OnStateValidationFailed(state);
                    }
                }
            }
        }

        public void SaveStates()
        {
            lock (_lock)
            {
                // 简化实现：保存所有状态到持久化存储
                var stateData = new Dictionary<string, object>();
                foreach (var state in _states.Values)
                {
                    stateData[state.StateId] = state.GetState();
                }
                
                // 这里可以保存到文件、数据库等
                // StateStorage.Save(stateData);
            }
        }

        public void LoadStates()
        {
            lock (_lock)
            {
                // 简化实现：从持久化存储加载所有状态
                // var stateData = StateStorage.Load();
                // foreach (var kvp in stateData)
                // {
                //     if (_states.TryGetValue(kvp.Key, out var state))
                //     {
                //         state.SetState(kvp.Value);
                //     }
                // }
            }
        }

        private void OnStateChanged(object? sender, StateChangedEventArgs e)
        {
            // 简化实现：处理状态变更
            Console.WriteLine($"State changed: {e.PropertyName} = {e.NewValue}");
            
            // 可以在这里添加业务逻辑，比如：
            // - 验证状态变更
            // - 触发相关状态更新
            // - 记录审计日志
        }

        private void OnStateValidationFailed(IBusinessState state)
        {
            // 简化实现：处理状态验证失败
            Console.WriteLine($"State validation failed: {state.StateId}");
            
            // 可以在这里添加错误处理逻辑
        }

        public IReadOnlyDictionary<string, IBusinessState> GetAllStates()
        {
            lock (_lock)
            {
                return new Dictionary<string, IBusinessState>(_states);
            }
        }
    }
}
```

### 2.2 验证框架

```csharp
// 简化实现：验证框架
// 原本实现：验证逻辑分散在各个类中
// 简化实现：通过统一的验证框架集中管理

using System;
using System.Collections.Generic;
using System.Linq;

namespace BannerlordModEditor.Common.Validation
{
    // 验证规则接口
    public interface IValidationRule
    {
        string RuleName { get; }
        ValidationResult Validate(object target);
        string ErrorMessage { get; }
        bool CanValidate(Type type);
    }

    // 验证结果
    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
        public Dictionary<string, object> Metadata { get; set; } = new();
    }

    // 验证器
    public class Validator : IValidator
    {
        private readonly List<IValidationRule> _rules = new();

        public ValidationResult Validate(object target)
        {
            var result = new ValidationResult();
            
            foreach (var rule in _rules.Where(r => r.CanValidate(target.GetType())))
            {
                var ruleResult = rule.Validate(target);
                
                if (!ruleResult.IsValid)
                {
                    result.IsValid = false;
                    result.Errors.AddRange(ruleResult.Errors);
                }
                
                result.Warnings.AddRange(ruleResult.Warnings);
                
                foreach (var kvp in ruleResult.Metadata)
                {
                    result.Metadata[kvp.Key] = kvp.Value;
                }
            }
            
            return result;
        }

        public ValidationResult ValidateProperty(object target, string propertyName)
        {
            var result = new ValidationResult();
            
            foreach (var rule in _rules.Where(r => r.CanValidate(target.GetType())))
            {
                if (rule is IPropertyValidationRule propertyRule)
                {
                    var ruleResult = propertyRule.ValidateProperty(target, propertyName);
                    
                    if (!ruleResult.IsValid)
                    {
                        result.IsValid = false;
                        result.Errors.AddRange(ruleResult.Errors);
                    }
                    
                    result.Warnings.AddRange(ruleResult.Warnings);
                }
            }
            
            return result;
        }

        public void AddRule(IValidationRule rule)
        {
            _rules.Add(rule);
        }

        public void RemoveRule(string ruleName)
        {
            _rules.RemoveAll(r => r.RuleName == ruleName);
        }

        public IReadOnlyList<IValidationRule> GetRules()
        {
            return _rules.AsReadOnly();
        }
    }

    // 属性验证规则接口
    public interface IPropertyValidationRule : IValidationRule
    {
        ValidationResult ValidateProperty(object target, string propertyName);
    }

    // 通用验证规则基类
    public abstract class ValidationRuleBase : IValidationRule
    {
        public abstract string RuleName { get; }
        public abstract string ErrorMessage { get; }
        public abstract bool CanValidate(Type type);
        public abstract ValidationResult Validate(object target);
    }

    // 必填字段验证规则
    public class RequiredRule : ValidationRuleBase, IPropertyValidationRule
    {
        private readonly string _propertyName;
        
        public RequiredRule(string propertyName)
        {
            _propertyName = propertyName;
        }

        public override string RuleName => $"Required_{_propertyName}";
        public override string ErrorMessage => $"Field '{_propertyName}' is required";

        public override bool CanValidate(Type type)
        {
            return type.GetProperty(_propertyName) != null;
        }

        public override ValidationResult Validate(object target)
        {
            return ValidateProperty(target, _propertyName);
        }

        public ValidationResult ValidateProperty(object target, string propertyName)
        {
            var result = new ValidationResult();
            
            if (propertyName != _propertyName)
            {
                result.IsValid = true;
                return result;
            }

            var property = target.GetType().GetProperty(propertyName);
            if (property == null)
            {
                result.IsValid = true;
                return result;
            }

            var value = property.GetValue(target);
            
            if (value == null)
            {
                result.IsValid = false;
                result.Errors.Add(ErrorMessage);
            }
            else if (value is string str && string.IsNullOrEmpty(str))
            {
                result.IsValid = false;
                result.Errors.Add(ErrorMessage);
            }
            else if (value is System.Collections.ICollection collection && collection.Count == 0)
            {
                result.IsValid = false;
                result.Errors.Add(ErrorMessage);
            }
            else
            {
                result.IsValid = true;
            }

            return result;
        }
    }

    // 字符串长度验证规则
    public class StringLengthRule : ValidationRuleBase, IPropertyValidationRule
    {
        private readonly string _propertyName;
        private readonly int _minLength;
        private readonly int _maxLength;

        public StringLengthRule(string propertyName, int minLength, int maxLength)
        {
            _propertyName = propertyName;
            _minLength = minLength;
            _maxLength = maxLength;
        }

        public override string RuleName => $"StringLength_{_propertyName}";
        public override string ErrorMessage => $"Field '{_propertyName}' must be between {_minLength} and {_maxLength} characters";

        public override bool CanValidate(Type type)
        {
            var property = type.GetProperty(_propertyName);
            return property != null && property.PropertyType == typeof(string);
        }

        public override ValidationResult Validate(object target)
        {
            return ValidateProperty(target, _propertyName);
        }

        public ValidationResult ValidateProperty(object target, string propertyName)
        {
            var result = new ValidationResult();
            
            if (propertyName != _propertyName)
            {
                result.IsValid = true;
                return result;
            }

            var property = target.GetType().GetProperty(propertyName);
            if (property == null)
            {
                result.IsValid = true;
                return result;
            }

            var value = property.GetValue(target) as string;
            
            if (value == null)
            {
                result.IsValid = true; // null检查由RequiredRule处理
                return result;
            }

            if (value.Length < _minLength || value.Length > _maxLength)
            {
                result.IsValid = false;
                result.Errors.Add(ErrorMessage);
            }
            else
            {
                result.IsValid = true;
            }

            return result;
        }
    }
}
```

## 3. 测试辅助工具实现

### 3.1 测试数据工厂

```csharp
// 简化实现：测试数据工厂
// 原本实现：测试数据创建分散在各个测试类中
// 简化实现：通过统一的工厂模式集中管理测试数据

using System;
using System.Collections.Generic;

namespace BannerlordModEditor.Common.Tests
{
    // 测试数据工厂
    public class TestDataFactory : ITestDataFactory
    {
        private readonly Dictionary<string, object> _templates = new();
        private readonly Dictionary<Type, Func<object>> _generators = new();

        public T CreateTestData<T>() where T : new()
        {
            return new T();
        }

        public T CreateTestData<T>(Action<T> configurator)
        {
            var data = new T();
            configurator(data);
            return data;
        }

        public T CreateTestData<T>(string templateName)
        {
            if (_templates.TryGetValue(templateName, out var template))
            {
                if (template is T typedTemplate)
                {
                    return (T)CloneObject(typedTemplate);
                }
            }
            
            throw new KeyNotFoundException($"Template '{templateName}' not found");
        }

        public T CreateTestData<T>(Dictionary<string, object> properties)
        {
            var data = new T();
            
            foreach (var kvp in properties)
            {
                var property = typeof(T).GetProperty(kvp.Key);
                if (property != null && property.CanWrite)
                {
                    property.SetValue(data, kvp.Value);
                }
            }
            
            return data;
        }

        public void RegisterTemplate<T>(string templateName, T template)
        {
            _templates[templateName] = template;
        }

        public void RegisterGenerator<T>(Func<T> generator)
        {
            _generators[typeof(T)] = () => generator()!;
        }

        private object CloneObject(object obj)
        {
            // 简化实现：使用序列化进行深拷贝
            // 在实际项目中，可以使用更高效的拷贝方法
            var json = System.Text.Json.JsonSerializer.Serialize(obj);
            return System.Text.Json.JsonSerializer.Deserialize(json, obj.GetType())!;
        }
    }

    // 测试断言助手
    public static class TestAssertionHelpers
    {
        public static void ShouldHaveValidXmlStructure(this string xml)
        {
            try
            {
                var doc = System.Xml.Linq.XDocument.Parse(xml);
                doc.Should().NotBeNull();
            }
            catch (Exception ex)
            {
                throw new ArgumentException("XML structure is invalid", ex);
            }
        }

        public static void ShouldBeXmlEquivalent(this string actual, string expected)
        {
            // 简化实现：使用XDocument进行比较
            var actualDoc = System.Xml.Linq.XDocument.Parse(actual);
            var expectedDoc = System.Xml.Linq.XDocument.Parse(expected);
            
            // 这里可以实现更复杂的XML比较逻辑
            actualDoc.ToString().Should().Be(expectedDoc.ToString());
        }

        public static void ShouldHaveValidSerializationRoundtrip<T>(this T obj)
        {
            var xml = XmlTestUtils.Serialize(obj);
            var deserialized = XmlTestUtils.Deserialize<T>(xml);
            
            // 这里可以实现更复杂的对象比较逻辑
            deserialized.Should().NotBeNull();
        }

        public static void ShouldHaveValidBusinessState<T>(this T obj) where T : IBusinessState
        {
            obj.ValidateState().Should().BeTrue();
        }

        public static void ShouldPassValidation<T>(this T obj, IValidator validator)
        {
            var result = validator.Validate(obj);
            result.IsValid.Should().BeTrue();
            result.Errors.Should().BeEmpty();
        }
    }
}
```

## 4. 使用示例

### 4.1 改进后的DO模型

```csharp
// 简化实现：改进后的CombatParametersDO
// 原本实现：需要手动实现所有ShouldSerialize方法
// 简化实现：通过基类和特性简化序列化控制

using System.Collections.Generic;
using System.Xml.Serialization;
using BannerlordModEditor.Common.Serialization;
using BannerlordModEditor.Common.Validation;

namespace BannerlordModEditor.Common.Models.DO
{
    [XmlRoot("base")]
    public class CombatParametersDO : XmlSerializableBase, IBusinessState
    {
        [XmlAttribute("type")]
        [XmlSerializationControl(ConditionMethod = "ShouldSerializeType")]
        public string? Type { get; set; }

        [XmlElement("definitions")]
        [XmlSerializationControl(ConditionMethod = "ShouldSerializeDefinitions")]
        public DefinitionsDO Definitions { get; set; } = new DefinitionsDO();
        
        [XmlIgnore]
        public bool HasDefinitions { get; set; } = false;
        
        [XmlArray("combat_parameters")]
        [XmlArrayItem("combat_parameter")]
        [XmlSerializationControl(ConditionMethod = "ShouldSerializeCombatParametersList")]
        public List<BaseCombatParameterDO> CombatParametersList { get; set; } = new List<BaseCombatParameterDO>();
        
        [XmlIgnore]
        public bool HasEmptyCombatParameters { get; set; } = false;

        // IBusinessState implementation
        public string StateId => $"CombatParameters_{Type ?? "Unknown"}";
        
        public object GetState()
        {
            return new
            {
                Type,
                HasDefinitions,
                HasEmptyCombatParameters,
                CombatParametersCount = CombatParametersList.Count
            };
        }

        public void SetState(object state)
        {
            if (state is dynamic dynamicState)
            {
                Type = dynamicState.Type;
                HasDefinitions = dynamicState.HasDefinitions;
                HasEmptyCombatParameters = dynamicState.HasEmptyCombatParameters;
            }
        }

        public bool ValidateState()
        {
            var validator = new Validator();
            validator.AddRule(new RequiredRule("Type"));
            
            var result = validator.Validate(this);
            return result.IsValid;
        }

        public event EventHandler<StateChangedEventArgs>? StateChanged;

        protected virtual void OnPropertyChanged(string propertyName, object? oldValue, object? newValue)
        {
            StateChanged?.Invoke(this, new StateChangedEventArgs
            {
                PropertyName = propertyName,
                OldValue = oldValue,
                NewValue = newValue,
                ChangeReason = "PropertyChanged"
            });
        }

        // 序列化控制方法
        protected virtual bool ShouldSerializeType() => !string.IsNullOrEmpty(Type);
        protected virtual bool ShouldSerializeDefinitions() => HasDefinitions && Definitions != null && Definitions.Defs.Count > 0;
        protected virtual bool ShouldSerializeCombatParametersList() => HasEmptyCombatParameters || (CombatParametersList != null && CombatParametersList.Count > 0);

        public object CreateSnapshot()
        {
            return new
            {
                Type,
                Definitions,
                CombatParametersList,
                HasDefinitions,
                HasEmptyCombatParameters
            };
        }

        public void RestoreSnapshot(object snapshot)
        {
            if (snapshot is dynamic dynamicSnapshot)
            {
                Type = dynamicSnapshot.Type;
                Definitions = dynamicSnapshot.Definitions;
                CombatParametersList = dynamicSnapshot.CombatParametersList;
                HasDefinitions = dynamicSnapshot.HasDefinitions;
                HasEmptyCombatParameters = dynamicSnapshot.HasEmptyCombatParameters;
            }
        }
    }
}
```

### 4.2 改进后的测试代码

```csharp
// 简化实现：改进后的测试代码
// 原本实现：测试代码重复，难以维护
// 简化实现：使用测试辅助工具简化测试编写

using System;
using Xunit;
using BannerlordModEditor.Common.Models.DO;
using BannerlordModEditor.Common.Tests;
using BannerlordModEditor.Common.Validation;

namespace BannerlordModEditor.Common.Tests
{
    public class CombatParametersDOTests
    {
        private readonly TestDataFactory _testDataFactory;
        private readonly IValidator _validator;

        public CombatParametersDOTests()
        {
            _testDataFactory = new TestDataFactory();
            _validator = new Validator();
            
            // 配置验证规则
            _validator.AddRule(new RequiredRule("Type"));
            
            // 注册测试数据模板
            _testDataFactory.RegisterTemplate("ValidCombatParameters", new CombatParametersDO
            {
                Type = "test_type",
                HasDefinitions = true,
                Definitions = new DefinitionsDO
                {
                    Defs = new List<DefDO>
                    {
                        new DefDO { Name = "test_def", Value = "test_value" }
                    }
                }
            });
        }

        [Fact]
        public void Serialize_ShouldProduceValidXml()
        {
            // Arrange
            var combatParams = _testDataFactory.CreateTestData<CombatParametersDO>(p =>
            {
                p.Type = "test_type";
                p.HasDefinitions = true;
            });

            // Act
            var xml = XmlTestUtils.Serialize(combatParams);

            // Assert
            xml.ShouldHaveValidXmlStructure();
        }

        [Fact]
        public void Deserialize_ShouldPreserveBusinessState()
        {
            // Arrange
            var original = _testDataFactory.CreateTestData<CombatParametersDO>("ValidCombatParameters");
            var xml = XmlTestUtils.Serialize(original);

            // Act
            var deserialized = XmlTestUtils.Deserialize<CombatParametersDO>(xml);

            // Assert
            deserialized.ShouldHaveValidBusinessState();
            deserialized.GetState().Should().BeEquivalentTo(original.GetState());
        }

        [Fact]
        public void BusinessState_ShouldBeValid()
        {
            // Arrange
            var combatParams = _testDataFactory.CreateTestData<CombatParametersDO>("ValidCombatParameters");

            // Act & Assert
            combatParams.ShouldPassValidation(_validator);
        }

        [Fact]
        public void SerializationRoundtrip_ShouldBeConsistent()
        {
            // Arrange
            var original = _testDataFactory.CreateTestData<CombatParametersDO>("ValidCombatParameters");

            // Act & Assert
            original.ShouldHaveValidSerializationRoundtrip<CombatParametersDO>();
        }

        [Fact]
        public void StateChanges_ShouldTriggerEvents()
        {
            // Arrange
            var combatParams = _testDataFactory.CreateTestData<CombatParametersDO>();
            var eventTriggered = false;
            
            combatParams.StateChanged += (sender, args) =>
            {
                eventTriggered = true;
                args.PropertyName.Should().Be("Type");
            };

            // Act
            combatParams.Type = "new_type";

            // Assert
            eventTriggered.Should().BeTrue();
        }
    }
}
```

## 5. 总结

通过这个改进的架构实现，我们解决了以下问题：

1. **XML序列化一致性**：通过统一的序列化控制框架，简化了序列化逻辑，提高了可维护性
2. **业务逻辑保持**：通过业务状态管理机制，确保业务逻辑的正确性和一致性
3. **测试覆盖率**：通过测试辅助工具，简化了测试编写，提高了测试效率
4. **质量监控**：通过验证框架和状态管理，实现了运行时的质量监控

这个架构不仅解决了当前的问题，还为未来的扩展和优化提供了良好的基础。